# Stage 3: Code Generation and Optimization (x86 Backend)

The third stage of a C compiler translates the optimized intermediate code into efficient **x86 assembly**, while applying advanced optimizations.

---

## 1. Backend Design for x86
- **Registers & ABI**: System V AMD64 calling convention (args in RDI, RSI, RDX, RCX, R8, R9; return in RAX).
- **Stack Frame**: Prologue sets up space for locals/spills, ensures 16-byte alignment; callee-saved regs pushed/popped.
- **Instruction Set Constraints**: Some ops require fixed regs (e.g., `DIV` → RAX/RDX).

---

## 2. Intermediate Representation (IR)
- Use **three-address code** with unlimited virtual registers.
- Organize into **Control Flow Graph (CFG)**.
- Convert to **Static Single Assignment (SSA)** for easier optimization.

---

## 3. Optimizations in SSA
- **Constant Propagation & Folding**
- **Dead Code Elimination**
- **Common Subexpression Elimination**
- **Loop optimizations**: LICM, strength reduction, unrolling.
- SSA simplifies use-def chains and liveness analysis.

---

## 4. Instruction Selection
- **Pattern matching (tree/DAG covering)** to map IR ops to x86.
- **Peephole optimizations** for suboptimal instruction sequences.
- Handle **two-address form** and complex addressing modes (e.g., `mov eax, [rbx+rcx*4]`).

---

## 5. Instruction Scheduling
- **Local scheduling** with list scheduling.
- Reorder to hide latencies and keep pipeline busy.
- Note: modern x86 CPUs do out-of-order execution, but static scheduling still helps.

---

## 6. Register Allocation
- **Graph coloring**: fewer spills, best runtime performance.
- **Linear scan**: faster compile time, used in JITs.
- Insert **spill code** for values that don’t fit in registers.

---

## 7. Stack Layout
- Allocate space for locals, spills, and outgoing call args.
- Maintain **callee-saved register discipline**.
- Support **red zone** (SysV ABI, 128 bytes under RSP for leaf functions).

---

## 8. Code Emission
- Output valid **AT&T or Intel syntax assembly**.
- Ensure instruction size correctness (movl vs movq).
- Emit `.globl`, labels, alignment directives.
- Final peephole cleanup: remove redundant moves, simplify branches.

---

## 9. Loop Optimizations
- **Unrolling**: reduce loop control overhead.
- **LICM**: hoist invariant computations.
- **Strength Reduction**: replace multiplies/divides with additions/shifts.

---

## 10. Data Flow & CFG
- Use CFG for:
  - **Reachability** (unreachable code removal).
  - **Liveness** (for register allocation).
  - **Reaching definitions** (constant propagation).
  - **Dominator tree** (loop detection, SSA).

---

✅ The backend should now output **optimized x86 assembly** ready for assembling and linking.
